
# server.py
import asyncio
import base64
import logging
import websockets
from datetime import datetime, timezone

from ocpp.routing import on
from ocpp.v16 import ChargePoint as cp
from ocpp.v16 import call_result
from ocpp.v16.enums import Action, RegistrationStatus

# -------------------------
# Config: set your credentials here
# -------------------------
USERNAME = "myuser"
PASSWORD = "mypassword"

# -------------------------
# Logging Configuration
# -------------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
)
logging.getLogger("ocpp").setLevel(logging.INFO)
logging.getLogger("websockets.server").setLevel(logging.INFO)

# -------------------------
# Wrapper for raw traffic logging (optional)
# -------------------------
class LoggingWebSocket:
    def __init__(self, ws, tag):
        self.ws = ws
        self.tag = tag

    async def recv(self):
        msg = await self.ws.recv()
        logging.info(f"[RAW RECV] <- {self.tag}: {msg}")
        return msg

    async def send(self, msg):
        logging.info(f"[RAW SEND] -> {self.tag}: {msg}")
        return await self.ws.send(msg)

    # Delegate other attributes/methods to underlying websocket
    def __getattr__(self, name):
        return getattr(self.ws, name)

# -------------------------
# OCPP ChargePoint Implementation
# -------------------------
class MyChargePoint(cp):
    @on(Action.boot_notification)
    async def on_boot_notification(
        self, charge_point_vendor, charge_point_model, **kwargs
    ):
        logging.info(
            f"[OCPP RECV] BootNotification vendor={charge_point_vendor}, model={charge_point_model}, extras={kwargs}"
        )
        response = call_result.BootNotification(
            current_time=datetime.now(tz=timezone.utc).isoformat(),
            interval=10,
            status=RegistrationStatus.accepted,
        )
        logging.info(f"[OCPP SEND] BootNotificationResponse: {response}")
        return response

# -------------------------
# Handshake / Connection Handler with Basic Auth
# -------------------------
async def on_connect(connection: websockets.WebSocketServerProtocol):
    # 1) Validate Basic Auth header
    auth_header = connection.request_headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Basic "):
        logging.warning("[AUTH] Missing or invalid Authorization header")
        # Close with a non-standard code; 4401 is commonly used for Unauthorized in WS contexts
        await connection.close(code=4401, reason="Unauthorized")
        return

    try:
        encoded = auth_header.split(" ", 1)[1]
        decoded = base64.b64decode(encoded).decode("utf-8")
        user, pwd = decoded.split(":", 1)
    except Exception as e:
        logging.warning(f"[AUTH] Malformed credentials: {e}")
        await connection.close(code=4401, reason="Unauthorized")
        return

    if user != USERNAME or pwd != PASSWORD:
        logging.warning(f"[AUTH] Invalid credentials for user={user}")
        await connection.close(code=4401, reason="Unauthorized")
        return

    logging.info(f"[AUTH] Authenticated user={user}")

    # 2) Proceed with OCPP handling
    charge_point_id = connection.request.path.split("/")[-1]
    logging.info(f"[CONNECT] ChargePoint ID={charge_point_id}, subprotocol={connection.subprotocol}")

    # Optional: wrap for raw logging
    wrapped_ws = LoggingWebSocket(connection, charge_point_id)

    charge_point = MyChargePoint(charge_point_id, wrapped_ws)

    try:
        await charge_point.start()
    except Exception as e:
        logging.exception(f"[ERROR] {charge_point_id}: {e}")
    finally:
        logging.info(f"[DISCONNECT] {charge_point_id}")

# -------------------------
# Main Server
# -------------------------
async def main():
    server = await websockets.serve(
        on_connect,
        "0.0.0.0",
        9000,
        subprotocols=["ocpp1.6"],
        # Note: If you run behind Codespaces public URL, TLS is terminated by GitHub.
        # If you run locally and need end-to-end TLS, add an ssl=ssl_context here.
    )
    logging.info("[SERVER] Listening on 0.0.0.0:9000 (OCPP 1.6 + Basic Auth)")
    await server.wait_closed()

if __name__ == "__main__":
    asyncio.run(main())
